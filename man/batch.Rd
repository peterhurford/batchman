% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/batch.R
\name{batch}
\alias{batch}
\title{batch maps a function to a batched version of that function.}
\usage{
batch(batch_fn, keys, splitting_strategy = NULL,
  combination_strategy = batchman::combine, size = 50, trycatch = FALSE,
  batchman.verbose = isTRUE(interactive()), stop = FALSE, retry = 0,
  sleep = 0, ncores = parallel::detectCores(), parallel = FALSE, key)
}
\arguments{
\item{batch_fn}{function. The method to batch over.}

\item{keys}{vector. The names of the keys within the function to batch.
Can be "..." if one is batching a splat function with no keys.}

\item{splitting_strategy}{function. The strategy used to split up inputs.
Leave NULL to use the versatile default splitting strategy.}

\item{combination_strategy}{function. The strategy used to recombine batches.
Defaults to class-agnostic combination.}

\item{size}{numeric. The size of the packets. Default 50.}

\item{trycatch}{logical. Whether to wrap the function in a tryCatch block.
Can be used to store and retrieve partial progress on an error.}

\item{batchman.verbose}{logical. Whether or not to announce progress by printing dots.}

\item{stop}{logical. Whether trycatch should stop if an error is raised.}

\item{retry}{integer. The number of times to retry on error. 0 for no retrying.}

\item{sleep}{integer. Time in seconds to sleep between batches.}

\item{ncores}{integer. Number of cores to use if parallel is set to true. Notice that it doesn't
work on windows.}

\item{parallel}{logical. Use parallel::mclapply to execute your batches. Incompatible with retry.}

\item{key}{vector. Same as /code{keys}.}
}
\value{
a batched version of the passed function.
}
\description{
batch maps a function to a batched version of that function.
}
\examples{
  batched_identity <- batch(identity, "x", combination_strategy = c, size = 10)
  batched_identity(seq(100))
  # Does identity, but in batches of 10.
}

